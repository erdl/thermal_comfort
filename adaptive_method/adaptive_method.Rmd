---
title: "Adaptive Method"
author: "Carlos V. Paradis"
date: "April 19, 2018"
output: 
  html_document:
    number_sections: true
    toc: true
    fig_width: 7
    fig_height: 4.5
    theme: cosmo
    highlight: tango
    code_folding: hide
---


```{r messages = FALSE, warning = FALSE}
s <- suppressPackageStartupMessages
s(library(zoo))
s(library(data.table))
s(library(lubridate))
s(library(knitr))
s(library(ggplot2))
s(library(stringr))
```

# Introduction

This notebook uses the outdoor temperature, indoor temperature and indoor airspeed to calculate:

 * Outdoor Rolling Average over last 14 days
 * Upper and Lower Bound of Comfort Level 
 * Number of Indoor Temperature Degrees Off the Upper or Lower Comfort Bound 

```{r}
# Parameters
n_hours_in_every_step <- 366 #Rolling mean will be based of the previous 14 days measurements
```

# How to use

Because there is still inconsistency in the input format, some manual work is still needed. 

For this notebook, 

Select in the next 3 blocks which you would like to use to reshape the data: Either one of the monitored houses, or one for the simulated data. Make sure that the other block is eval = FALSE. The remaining blocks should run just as fine.

Take note in each block indoor and outdoor temperatures may be loaded in separate files, so check all file paths to ensure they are as expected. 

For monitored data, the outdoor and temperature tables are separate (although the outdoor table is reused for all houses). For simulated data, both outdoor and indoor are part of the same table. 

Contrary to the PMV notebook, indoor air speed is not required to be changed (fpm 0, 120, 200), as they are plotted as lines.

# Method

## Monitored Data

Use the following code block if the Adaptive Method will be used in **monitored** data.

```{r Monitored House 8, eval = TRUE}
data_type <- "Monitored House 8 Living Room" #used in the plot title
save_path_and_name <- "~/Desktop/house8-living-room-adaptive.png"

# Outdoor

## Perform Hourly Average

# Load and rename columns for consistency -- no space and no upper case column names
outdoor <- fread("~/Github/erdl/thermal_comfort/adaptive_method/data/houses_outdoor_temperature.csv")
colnames(outdoor) <- c("timestamp","outdoor_temperature_f")

# Identify the right types for each column
outdoor$timestamp <- ymd_hms(outdoor$timestamp,tz="HST")
outdoor$outdoor_temperature_f <- as.numeric(outdoor$outdoor_temperature_f)
outdoor$ymd_h <- outdoor$timestamp

#Ensure timestamps are ordered. Database does not guarantee that.
outdoor <- outdoor[order(timestamp)]

# Reset the minute and second to 0, so we can group by ymd_h. 
minute(outdoor$ymd_h) <- 0
second(outdoor$ymd_h) <- 0
outdoor <- outdoor[,.(outdoor_temperature=mean(outdoor_temperature_f)),by="ymd_h"]


# Indoor Temperature

indoor <- fread("~/Github/erdl/thermal_comfort/adaptive_method/data/monitored/house8/house8_livingroom_adaptive.csv")
colnames(indoor) <- c("timestamp","building_id","power","indoor_temperature","rh")
indoor <- indoor[,.(timestamp,indoor_temperature)]

# Correct types
indoor$timestamp <- dmy_hms(indoor$timestamp)
indoor$indoor_temperature <- as.numeric(indoor$indoor_temperature)
indoor$ymd_h <- indoor$timestamp

#Ensure timestamps are ordered. Database does not guarantee that.
indoor <- indoor[order(timestamp)]

# Reset the minute and second to 0, so we can group by ymd_h. 
minute(indoor$ymd_h) <- 0
second(indoor$ymd_h) <- 0
indoor <- indoor[,.(indoor_temperature=mean(indoor_temperature)),by="ymd_h"]
colnames(indoor) <- c("timestamp","indoor_temperature")
```

```{r Monitored House 2, eval = FALSE}
data_type <- "Monitored House 2 Living Room" #used in the plot title
save_path_and_name <- "~/Desktop/house2-living-room.png"

# Outdoor

## Perform Hourly Average

# Load and rename columns for consistency -- no space and no upper case column names
outdoor <- fread("~/Github/erdl/thermal_comfort/adaptive_method/data/houses_outdoor_temperature.csv")
colnames(outdoor) <- c("timestamp","outdoor_temperature_f")

# Identify the right types for each column
outdoor$timestamp <- ymd_hms(outdoor$timestamp,tz="HST")
outdoor$outdoor_temperature_f <- as.numeric(outdoor$outdoor_temperature_f)
outdoor$ymd_h <- outdoor$timestamp

#Ensure timestamps are ordered. Database does not guarantee that.
outdoor <- outdoor[order(timestamp)]

# Reset the minute and second to 0, so we can group by ymd_h. 
minute(outdoor$ymd_h) <- 0
second(outdoor$ymd_h) <- 0
outdoor <- outdoor[,.(outdoor_temperature=mean(outdoor_temperature_f)),by="ymd_h"]

# Indoor Temperature

# To calculate the boundaries and acceptance, besides the outdoor rolling average, we also need the indoor temperature, and air speed. Because the tables are different, i.e. indoor's temperature and airspeed are hourly, wherewas the outdoor was originally at a minute sampling rate, there is a chance after the rolling average is calculated the number of rows will not match between both tables. This script matches the minimum number of rows between them both.

# load indoor data
indoor <- fread("~/Github/erdl/thermal_comfort/adaptive_method/data/monitored/house2/house2_livingroom_temperature.csv")[,.(reading_timestamp,value)]
colnames(indoor) <- c("timestamp","indoor_temperature")
indoor$timestamp <- ymd_hms(indoor$timestamp,tz="HST")

# Identify the right types for each column
indoor$timestamp <- ymd_hms(indoor$timestamp,tz="HST")
indoor$indoor_temperature <- as.numeric(indoor$indoor_temperature)
indoor$ymd_h <- indoor$timestamp

#Ensure timestamps are ordered. Database does not guarantee that.
indoor <- indoor[order(timestamp)]

# Reset the minute and second to 0, so we can group by ymd_h. 
minute(indoor$ymd_h) <- 0
second(indoor$ymd_h) <- 0
indoor <- indoor[,.(indoor_temperature=mean(indoor_temperature)),by="ymd_h"]
colnames(indoor) <- c("timestamp","indoor_temperature")

```

## Simulated Data

Use the following code block if the Adaptive Method will be used in **simulated** data.

```{r Simulated, eval = FALSE, warning = FALSE}
data_type <- "Simulated House 2 Run 1" #used in the plot title
save_path_and_name <- "~/Desktop/house2-run-1.png"
# For simulated data, only 1 table, generated by BEopt, is necessary, as it contains both outdoor and indoor simulated data.

dt <- fread("~/Github/erdl/thermal_comfort/adaptive_method/data/simulated/house-2-run-1.csv")
colnames(dt) <- sapply(str_split(colnames(dt)," - "),"[[",2)
dt <- dt[2:.N,.(outdoor_temperature=as.numeric(`Weather|Outdoor Drybulb`), #First row is units
            indoor_temperature=as.numeric(`Living Space|Indoor Temperature`))]

outdoor <- dt$outdoor_temperature

# Add 366 data points to the start of outdoor vector so indoor first 366 points are not lost when calculating rolling mean.
outdoor <- c(tail(outdoor,n=365),outdoor)

# Create fake timestamp id

timestamp <- ymd_hms("1800-01-01 00:00:00") + hours(1:length(outdoor))

outdoor <- data.table(ymd_h=timestamp,outdoor_temperature=outdoor)

# Do the same for temperature:

dt$timestamp <- ymd_hms("1800-01-01 00:00:00") + hours(366:(nrow(dt)+366))

indoor <- dt[,.(timestamp,indoor_temperature)]
```

# Rolling Mean

```{r}
## Perform 14 Days Hourly Rolling Average

# Next, the hourly temperature is used to calculate the 14 days temperature backwards. 

# Invert table so slide window goes backwards
inverted_outdoor <- outdoor[order(-ymd_h)]

# Calculate rolling mean and reverts back the output from the rolling mean. 
rolling_mean_outdoor_temperature <- rev(rollapply(inverted_outdoor$outdoor_temperature,
                                            width=n_hours_in_every_step,
                                            FUN=mean))

outdoor <- outdoor[n_hours_in_every_step:.N]  
outdoor$rolling_mean_outdoor_temperature <- rolling_mean_outdoor_temperature
colnames(outdoor) <- c("timestamp","outdoor_temperature","rolling_mean_outdoor_temperature")
```

# Merge Outdoor and Indoor

```{r}
dt <- merge(outdoor,indoor,by="timestamp")

# Add Rolling Mean Vector to Simulation Data Column-Wise. Notice this is NOT an inner join.
#min_rows <- min(length(rolling_temperature_f_mean),nrow(simulation_data))

#dt <- simulation_data[1:min_rows]
#dt$rolling_temperature_f_mean <- rolling_temperature_f_mean[1:min_rows]
```


## Calculate boundaries

The comfort level boundaries are calculated using the outdoor rolling average adjusted by the indoor airspeed. 

```{r}
calculate_air_speed_adjustment <- function(in_air_speed){
  return(0.0153*in_air_speed+0.4333)
}

dt$upper_bound <- 0.31*dt$rolling_mean_outdoor_temperature + 60.5
dt$upper_bound_0_fpm <- dt$upper_bound + calculate_air_speed_adjustment(0)
dt$upper_bound_120_fpm <- dt$upper_bound + calculate_air_speed_adjustment(120)
dt$upper_bound_200_fpm <- dt$upper_bound + calculate_air_speed_adjustment(200)


dt$lower_bound <- 0.31*dt$rolling_mean_outdoor_temperature + 47.9 
```

## Calculate Acceptance

With the comfort upper and lower bound, we then compare the indoor temperature against them.

```{r}
dt$acceptable_temperature_80 <- NA_character_
dt[indoor_temperature > upper_bound]$acceptable_temperature_80 <- "Unacceptable Hot"
dt[indoor_temperature < lower_bound]$acceptable_temperature_80 <- "Unacceptable Cold"
dt[indoor_temperature > lower_bound & indoor_temperature < upper_bound]$acceptable_temperature_80 <- "Acceptable"
```

## Calculate Degrees Off

In addition, how far higher or lower than the upper and lower bound respectively can also be calculated.

```{r}
dt$degrees_off <- NA_real_

dt[indoor_temperature > upper_bound]$degrees_off <- dt[indoor_temperature > upper_bound]$indoor_temperature - dt[indoor_temperature > upper_bound]$upper_bound

dt[indoor_temperature < lower_bound]$degrees_off <- dt[indoor_temperature < lower_bound]$indoor_temperature - dt[indoor_temperature < lower_bound]$lower_bound

dt[indoor_temperature > lower_bound & indoor_temperature < upper_bound]$degrees_off <- 0
```

# Output Table

Finally, we the output table containing all the calculated information.

```{r}
kable(head(dt))
```

# Plot

```{r fig.width= 9, fig.height=4}
n_acceptable <- nrow(dt[acceptable_temperature_80 == "Acceptable"])
n_unacceptable <- nrow(dt[acceptable_temperature_80 != "Acceptable"])

percent <- function(x, digits = 2, format = "f", ...) {
  paste0(formatC(100 * x, format = format, digits = digits, ...), "%")
}

n_acceptable_percent <- percent(n_acceptable/(n_acceptable+n_unacceptable))
n_unacceptable_percent <- percent(n_unacceptable/(n_acceptable+n_unacceptable))

st <- min(dt$timestamp)
et <- max(dt$timestamp)
p_start_time <- paste0(year(st),"-",month(st),"-",day(st))
p_end_time <- paste0(year(et),"-",month(et),"-",day(et))

status <- paste0(p_start_time," to ",p_end_time," | Acceptable: ",n_acceptable," (",n_acceptable_percent,") ; Unacceptable: ",n_unacceptable," (",n_unacceptable_percent,")")



p <- ggplot(data = dt) + 
  geom_point(aes(rolling_mean_outdoor_temperature,indoor_temperature,color=acceptable_temperature_80)) + 
  geom_line(aes(rolling_mean_outdoor_temperature,upper_bound_200_fpm),color="black") + 
  geom_line(aes(rolling_mean_outdoor_temperature,upper_bound_120_fpm),color="black") + 
  geom_line(aes(rolling_mean_outdoor_temperature,upper_bound),color="black") + 
  geom_line(aes(rolling_mean_outdoor_temperature,lower_bound),color="black") + 
  
  geom_text(aes(max(dt$rolling_mean_outdoor_temperature)+0.2,max(dt$upper_bound_200_fpm), label = "fpm 200", vjust = -1), size = 3) + 
  geom_text(aes(max(dt$rolling_mean_outdoor_temperature)+0.2,max(dt$upper_bound_120_fpm), label = "fpm 120", vjust = -1), size = 3) + 
  geom_text(aes(max(dt$rolling_mean_outdoor_temperature)+0.2,max(dt$upper_bound)-0.6, label = "no adj", vjust = -1), size = 3) + 
  geom_text(aes(max(dt$rolling_mean_outdoor_temperature)+0.2,max(dt$lower_bound), label = "no adj", vjust = -1), size = 3) + 
  
  
  theme_minimal() + 
  scale_colour_manual(values=c("Unacceptable Cold"="#0072B2","Acceptable"="#009E73","Unacceptable Hot"="#D55E00")) +
  ggtitle(paste0("Adaptive Method - ",data_type), subtitle = status) + 
  ylab("Indoor Temperature (F)") + 
  xlab("Rolling Mean Outdoor Temperature (F)") + 
  labs(color="Acceptable Temperature 80")

p
```

```{r}
# 28.34 is pixel to cm, see: http://www.answers.com/Q/How_many_pixels_to_one_centimeter
ggsave(filename=save_path_and_name,plot=p,
     width=1340/(28.34*3),
     height=585/(28.34*3))
```


